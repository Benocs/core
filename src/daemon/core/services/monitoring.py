# various CORE services that implement network and host monitoring
#
# Copyright (C) 2014 Robert Wuttke <robert@benocs.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


import os

from core.service import CoreService, addservice
from core.misc.ipaddr import IPv4Prefix, IPv6Prefix
from core.misc.ipaddr import isIPv4Address, isIPv6Address
from core.misc.ipaddr import Loopback, Interface
from core.misc.utils import *
from core.constants import *

from core.services import utility

from core.services import service_helpers

class MonitoringService(CoreService):
        """ Parent class for monitoring services """

        _name = "Monitoring Service"
        _group = "Monitoring"
        _depends = ()
        _dirs = ()
        _configs = ()
        _startindex = 90
        _startup = ()
        _shutdown = ()

        @classmethod
        def generateconfig(cls,  node, filename, services):
                return ""

class NetFlow9ProbeService(MonitoringService):
    _name = "NetFlow9Probe"
    _configs = ("startnetflow9probe.sh", "stopnetflow9probe.sh",
            "pmacctd_netflow9probe.conf")
    _dirs = ()
    _startup = ("sh startnetflow9probe.sh",)
    _shutdown = ("sh stopnetflow9probe.sh",)
    _validate = ()
    # TODO: wait for IGP to converge before starting monitoring (pmacctd will exit if no
    # route to collector is available)
    _starttime = 60

    @classmethod
    def generateconfig(cls, node, filename, services):
        ''' Use a startup script for launching sshd in order to wait for host
                key generation.
        '''

        if filename == "startnetflow9probe.sh":
            return cls.generateStartScript(cls._configs[2])
        elif filename == "stopnetflow9probe.sh":
            return cls.generateStopScript()
        elif filename == "pmacctd_netflow9probe.conf":
            return cls.generateConf(node)

    @staticmethod
    def generateStartScript(netflow9_cfgfile):
        return """\
#!/bin/sh
# auto-generated by pmacctd NetFlow9 service (monitoring.py)

pmacctd -f %s
""" % (netflow9_cfgfile)

    @staticmethod
    def generateStopScript():
        return """\
#!/bin/sh
# auto-generated by pmacctd NetFlow9 service (monitoring.py)

#kill $(cat /var/run/pmacctd_nf9.pid)
#kill -9 $(cat /var/run/pmacctd_nf9.pid)
killall pmacctd
"""

    @staticmethod
    def nodewalker_callback(startnode, currentnode):
        result = []
        # check if remote node is netflow9sink and for same AS
        if NetFlow9SinkService in currentnode.services and \
                startnode.netid == currentnode.netid:
            if currentnode.enable_ipv6 and startnode.enable_ipv6:
                result = ['nfprobe_receiver: ', str(currentnode.getLoopbackIPv6()),
                        ':2055\n']
            elif currentnode.enable_ipv4 and startnode.enable_ipv4:
                result = ['nfprobe_receiver: ', str(currentnode.getLoopbackIPv4()),
                        ':2055\n']
        return result

    @staticmethod
    def generateConf(node):
        confstr_list =  ["""\
! auto-generated by pmacctd NetFlow9 service (monitoring.py)

!pidfile: /var/run/pmacctd_nf9.pid

daemonize: true

"""]
        for intf in node.netifs():
            confstr_list.extend(['interface: ', intf.name, '\n'])

        confstr_list.append(
"""
!aggregate: src_host, dst_host, src_port, dst_port, proto, tos
plugins: nfprobe

""")

        # add any nfprobe9sink which is on our AS to the list of collectors
        service_helpers.nodewalker(node, node, confstr_list, NetFlow9ProbeService.nodewalker_callback)

        confstr_list.append(
"""
nfprobe_version: 9

nfprobe_timeouts: tcp=120:tcp.rst=4:tcp.fin=10:udp=10:icmp=10:general=120:expint=3:maxlife=3600
""")

        return ''.join(confstr_list)

addservice(NetFlow9ProbeService)


class NetFlow9SinkService(MonitoringService):
    """ dummy service marking nodes that implement a NetFlow9 collector.
            this is used by NetFlow9ProbeService to find collectors
    """
    _name = "NetFlow9Sink"
    _group = "Service Flags"

addservice(NetFlow9SinkService)

class ICMPProbeService(MonitoringService):
    _name = "ICMPProbe"
    _depends = ("Cron",)
    _configs = (
            'start_icmp_probe_lo.sh',
            'icmp_probe_lo.sh',
            'icmp_probe_lo.hosts',
            'icmp_probe_lo.hosts.verbose',
            'start_icmp_probe_if.sh',
            'icmp_probe_if.sh',
            'icmp_probe_if.hosts',
            'icmp_probe_if.hosts.verbose',
            )
    _dirs = ()
    _startup = (
            "rm -f /tmp/icmp_probe_lo.stop",
            "rm -f /tmp/icmp_probe_if.stop",
            "bash start_icmp_probe_lo.sh",
            "bash start_icmp_probe_if.sh",
            )
    _shutdown = ("> /tmp/icmp_probe_lo.stop", "> /tmp/icmp_probe_if.stop",)
    _validate = ()
    # TODO: wait for IGP to converge before starting to scan
    #_starttime = 300

    @classmethod
    def generateconfig(cls, node, filename, services):
        if filename == 'start_icmp_probe_lo.sh':
            return cls.generateStartLo(node)
        elif filename == 'icmp_probe_lo.sh':
            return cls.generateConfLo(node)
        elif filename == 'icmp_probe_lo.hosts':
            return cls.generateHostsLo(node)
        elif filename == 'icmp_probe_lo.hosts.verbose':
            return cls.generateHostsLo(node, True)
        elif filename == 'start_icmp_probe_if.sh':
            return cls.generateStartIf(node)
        elif filename == 'icmp_probe_if.sh':
            return cls.generateConfIf(node)
        elif filename == 'icmp_probe_if.hosts':
            return cls.generateHostsIf(node)
        elif filename == 'icmp_probe_if.hosts.verbose':
            return cls.generateHostsIf(node, True)

    @staticmethod
    def generateStartLo(node):
        confstr =  """\
#!/bin/bash

grep -v "icmp_probe_lo.sh" /etc/crontab && echo "*/5 * * * * root (cd $(pwd); bash $(pwd)/icmp_probe_lo.sh)" >> /etc/crontab

bash ./icmp_probe_lo.sh &
"""
        return confstr

    @staticmethod
    def generateConfLo(node):
        confstr =  """\
#!/bin/bash

set -e

error=0
now=$(date +%Y%m%d-%H%M)
mkdir -p icmp_probe
out=icmp_probe/icmp_probe_lo.result.${now}

function abort {
  echo "error at host: $host" >> ${out}
  error=1
}

if [ \! -e /tmp/icmp_probe_lo.stop ]; then
    > ${out}

    for host in $(cat icmp_probe_lo.hosts); do
        nice -n19 ping -c1 -w1 $host > /dev/null || abort
    done

    [ $error -eq 0 ] && echo "all ok" > ${out}
fi
"""
        return confstr

    @staticmethod
    def generateHostsLo(node, verbose=False):
        confstr_list =  []
        if not verbose:
            service_helpers.nodewalker(node, node, confstr_list,
                    ICMPProbeService.nodewalker_lo_callback)
        else:
            service_helpers.nodewalker(node, node, confstr_list,
                    ICMPProbeService.nodewalker_lo_verbose_callback)
        return ''.join(confstr_list)

    @staticmethod
    def nodewalker_lo_callback(startnode, currentnode):
        result = []
        #if currentnode.enable_ipv6 and startnode.enable_ipv6:
        #    result.append(str(currentnode.getLoopbackIPv6()))
        if currentnode.enable_ipv4 and startnode.enable_ipv4:
            result.extend([str(currentnode.getLoopbackIPv4()), '\n'])
        return result

    @staticmethod
    def nodewalker_lo_verbose_callback(startnode, currentnode):
        result = []
        #if currentnode.enable_ipv6 and startnode.enable_ipv6:
        #    result.append(str(currentnode.getLoopbackIPv6()))
        if currentnode.enable_ipv4 and startnode.enable_ipv4:
            result.extend([str(currentnode.getLoopbackIPv4()),
                    ' ', currentnode.name, '\n'])
        return result

    @staticmethod
    def generateStartIf(node):
        confstr =  """\
#!/bin/bash

grep -v "icmp_probe_if" /etc/crontab && echo "*/5 * * * * root (cd $(pwd); bash $(pwd)/icmp_probe_if.sh)" >> /etc/crontab

bash ./icmp_probe_if.sh &
"""
        return confstr

    @staticmethod
    def generateConfIf(node):
        confstr =  """\
#!/bin/bash

set -e

error=0
now=$(date +%Y%m%d-%H%M)
mkdir -p icmp_probe
out=icmp_probe/icmp_probe_if.result.${now}

function abort {
  echo "error at host: $host" >> ${out}
  error=1
}

if [ \! -e /tmp/icmp_probe_lo.stop ]; then
    > ${out}

    for host in $(cat icmp_probe_if.hosts); do
        nice -n19 ping -c1 -w1 $host > /dev/null || abort
    done

    [ $error -eq 0 ] && echo "all ok" > ${out}
fi
"""
        return confstr

    @staticmethod
    def generateHostsIf(node, verbose=False):
        confstr_list =  []
        if not verbose:
            service_helpers.nodewalker(node, node, confstr_list,
                    ICMPProbeService.nodewalker_if_callback)
        else:
            service_helpers.nodewalker(node, node, confstr_list,
                    ICMPProbeService.nodewalker_if_verbose_callback)
        return ''.join(confstr_list)

    @staticmethod
    def nodewalker_if_callback(startnode, currentnode):
        result = []
        #if currentnode.enable_ipv6 and startnode.enable_ipv6:
        #    result.append(str(currentnode.getLoopbackIPv6()))
        if currentnode.enable_ipv4 and startnode.enable_ipv4:
            for intf in currentnode._netif.values():
                for addr in intf.addrlist:
                    if isIPv4Address(addr):
                        result.extend([addr.partition('/')[0], '\n'])
        return result

    @staticmethod
    def nodewalker_if_verbose_callback(startnode, currentnode):
        result = []
        #if currentnode.enable_ipv6 and startnode.enable_ipv6:
        #    result.append(str(currentnode.getLoopbackIPv6()))
        if currentnode.enable_ipv4 and startnode.enable_ipv4:
            for intf in currentnode._netif.values():
                for addr in intf.addrlist:
                    if isIPv4Address(addr):
                        result.extend([addr.partition('/')[0],
                        ' ', currentnode.name, '\n'])
        return result

addservice(ICMPProbeService)
