# various CORE services that implement network and host monitoring
#
# Copyright (C) 2014 Robert Wuttke <robert@benocs.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


import os

from core.service import CoreService, addservice
from core.misc.ipaddr import IPv4Prefix, IPv6Prefix
from core.misc.ipaddr import isIPv4Address, isIPv6Address
from core.misc.ipaddr import Loopback, Interface
from core.misc.utils import *
from core.constants import *

from core.services import utility

from core.services import service_flags
from core.services import service_helpers

class MonitoringService(CoreService):
        """ Parent class for monitoring services """

        _name = "Monitoring Service"
        _group = "Monitoring"
        _depends = ()
        _dirs = ()
        _configs = ()
        _startindex = 90
        _startup = ()
        _shutdown = ()

        @classmethod
        def generateconfig(cls,  node, filename, services):
                return ""

class NetFlow9ProbeServicePMAcct(MonitoringService):
    _name = "NetFlow9Probe"
    _configs = ("startnetflow9probe.sh", "stopnetflow9probe.sh",
            "pmacctd_netflow9probe.conf")
    _dirs = ()
    _startup = ("sh startnetflow9probe.sh",)
    _shutdown = ("sh stopnetflow9probe.sh",)
    _validate = ()
    # TODO: wait for IGP to converge before starting monitoring (pmacctd will exit if no
    # route to collector is available)
    _starttime = 60

    @classmethod
    def generateconfig(cls, node, filename, services):
        ''' Use a startup script for launching sshd in order to wait for host
                key generation.
        '''

        if filename == "startnetflow9probe.sh":
            return cls.generateStartScript(cls._configs[2])
        elif filename == "stopnetflow9probe.sh":
            return cls.generateStopScript()
        elif filename == "pmacctd_netflow9probe.conf":
            return cls.generateConf(node)

    @staticmethod
    def generateStartScript(netflow9_cfgfile):
        return """\
#!/bin/sh
# auto-generated by pmacctd NetFlow9 service (monitoring.py)

pmacctd -f %s
""" % (netflow9_cfgfile)

    @staticmethod
    def generateStopScript():
        return """\
#!/bin/sh
# auto-generated by pmacctd NetFlow9 service (monitoring.py)

#kill $(cat /var/run/pmacctd_nf9.pid)
#kill -9 $(cat /var/run/pmacctd_nf9.pid)
killall pmacctd
"""

    @staticmethod
    def nodewalker_callback(startnode, currentnode):
        result = []
        # check if remote node is netflow9sink and for same AS
        if NetFlow9SinkService in currentnode.services and \
                startnode.netid == currentnode.netid:
            if currentnode.enable_ipv6 and startnode.enable_ipv6:
                result = ['nfprobe_receiver: ', str(currentnode.getLoopbackIPv6()),
                        ':2055\n']
            elif currentnode.enable_ipv4 and startnode.enable_ipv4:
                result = ['nfprobe_receiver: ', str(currentnode.getLoopbackIPv4()),
                        ':2055\n']
        return result

    @staticmethod
    def generateConf(node):
        confstr_list =  ["""\
! auto-generated by pmacctd NetFlow9 service (monitoring.py)

!pidfile: /var/run/pmacctd_nf9.pid

daemonize: true

"""]
        for intf in node.netifs():
            confstr_list.extend(['interface: ', intf.name, '\n'])

        confstr_list.append(
"""
!aggregate: src_host, dst_host, src_port, dst_port, proto, tos
plugins: nfprobe

""")

        # add any nfprobe9sink which is on our AS to the list of collectors
        service_helpers.nodewalker(node, node, confstr_list,
                NetFlow9ProbeServicePMAcct.nodewalker_callback)

        confstr_list.append(
"""
nfprobe_version: 9

nfprobe_timeouts: tcp=120:tcp.rst=4:tcp.fin=10:udp=10:icmp=10:general=120:expint=3:maxlife=3600
""")

        return ''.join(confstr_list)

class NetFlow9ProbeServiceSoftflowd(MonitoringService):
    _name = "NetFlow9Probe"
    _configs = ("startprobe.sh", "startnetflow9probe.sh", "stopnetflow9probe.sh",)
    _dirs = ()
    _startup = ("sh startnetflow9probe.sh",)
    _shutdown = ("sh stopnetflow9probe.sh",)
    _validate = ()
    _starttime = 60

    @classmethod
    def generateconfig(cls, node, filename, services):
        if filename == "startprobe.sh":
            return cls.generateStartProbe(node)
        elif filename == "startnetflow9probe.sh":
            return cls.generateStartScript(node)
        elif filename == "stopnetflow9probe.sh":
            return cls.generateStopScript()

    @staticmethod
    def generateStartProbe(node):
        return """\
#!/bin/bash

daemon_cmd=$1
collector=$2

[ -z "$1" ] && exit 1
[ -z "$2" ] && exit 1

failure_sleep=3
started=0
collector_probe_cmd="ping -c1 -w1 -n $collector"

echo "collector: \"$collector\""
echo "daemon cmd: \"$daemon_cmd\""

while [ $started -eq 0 ]; do

    echo "probing collector using: \"$collector_probe_cmd\""
    $collector_probe_cmd && started=1 && $daemon_cmd || sleep $failure_sleep
done
"""

    @classmethod
    def generateStartScript(cls, node):
        """ enable Netflow probe on peering links """

        config_list = []

        if not service_flags.EGP in node.services:
            config_list.append('# this is no border-router. disabling Netflow\n')
            return ''.join(config_list)

        config_list.extend([
                '#!/bin/sh\n',
                '# auto-generated by %s service (monitoring.py)\n\n' % cls._name
                ])
        base_sflowd_argv = ['/usr/local/sbin/softflowd']

        if node.enable_ipv6:
            # monitor IPv6
            base_sflowd_argv.append(' -6')

        # export NetFlow9
        base_sflowd_argv.append(' -v9')

        # transport layer protocol for exporting packets: UDP
        base_sflowd_argv.append(' -Pudp')

        # Set flow tracking level (default: full)
        base_sflowd_argv.append(' -Tfull')

        # Track up to 65536 flows
        base_sflowd_argv.append(' -m65536 ')

        # flow timeout definitions
        base_sflowd_argv.append((' -ttcp=120 -ttcp.rst=4 -ttcp.fin=10'
                            ' -tudp=10 -ticmp=10 -tgeneral=120 -tmaxlife=600'))

        # check every three seconds for expired flows
        base_sflowd_argv.append(' -texpint=3')

        # add any nfprobe9sink which is on our AS to the list of collectors
        collectors = []
        service_helpers.nodewalker(node, node, collectors,
                NetFlow9ProbeServiceSoftflowd.nodewalker_callback)

        for collector in collectors:
            base_sflowd_argv.append(' -n %s:2055' % collector)

        for localnetif in node.netifs():
            # do not ever include control interfaces in anything
            if hasattr(localnetif, 'control') and localnetif.control == True:
                continue

            sflowd_argv = []

            for idx, net_netif in list(localnetif.net._netif.items()):
                candidate_node = net_netif.node

                # skip our own interface
                if localnetif == net_netif:
                    continue

                # found peering link
                # enable netflow on this interface
                if not node.netid == net_netif.node.netid and \
                        service_flags.EGP in net_netif.node.services:

                    # get SNMP idx of this interface
                    result, stdouterr = node.cmdresult(
                            ['/opt/BENOCS/bin/ifindex', str(localnetif.name)])

                    if result != 0:
                        node.warn(('Could not determine SNMP interface number '
                                'for interface: %s - error: %s' % (
                                str(localnetif.name),
                                str(stdouterr))))
                        sflowd_argv.append((' -i %s' % str(localnetif.name)))
                    else:
                        stdouterr = stdouterr.decode().strip()
                        sflowd_argv.append((' -i %s:%s' % (str(stdouterr),
                                str(localnetif.name))))
                    sflowd_argv.append((' -p /var/run/softflowd.%s.pid' %
                            (str(localnetif.name))))
                    sflowd_argv.append((' -c /var/run/softflowd.%s.ctl' %
                            (str(localnetif.name))))

                    # although, these options erase themself, somehow it won't start otherwise
                    sflowd_argv.append(' -D')
                    #/usr/local/sbin/softflowd -6 -i 255:eth2 -n 172.16.56.11:2055 -Pudp -v9 -ttcp=3 -ttcp.fin=3 -tmaxlife=5 -p /var/run/softflowd.eth2.pid  -c /var/run/softflowd.eth2.ctl -D &

                    # TODO: make this work when multiple collectors are present
                    if len(collectors) > 0:
                        config_list.extend(['bash startprobe.sh ', '"', ''.join(base_sflowd_argv),
                                ''.join(sflowd_argv), '" ', collectors[0], ' &', '\n'])

                    # skip checking of other nodes on this link. they wouldn't
                    # change any behavior, anyway. continue with next local
                    # interface
                    break

        return ''.join(config_list)

    @staticmethod
    def generateStopScript():
        return """\
#!/bin/sh

killall softflowd
"""

    @staticmethod
    def nodewalker_callback(startnode, currentnode):
        result = []
        # check if remote node is netflow9sink and for same AS
        if NetFlow9SinkService in currentnode.services and \
                startnode.netid == currentnode.netid:
            if currentnode.enable_ipv6 and startnode.enable_ipv6:
                result = [str(currentnode.getLoopbackIPv6())]
                #result = [' -n ', str(currentnode.getLoopbackIPv6()),
                #        ':2055']
            elif currentnode.enable_ipv4 and startnode.enable_ipv4:
                result = [str(currentnode.getLoopbackIPv4())]
                #result = [' -n ', str(currentnode.getLoopbackIPv4()),
                #        ':2055']
        return result

class NetFlow9ProbeService(NetFlow9ProbeServiceSoftflowd):
    pass

addservice(NetFlow9ProbeService)


class NetFlow9SinkService(MonitoringService):
    """ dummy service marking nodes that implement a NetFlow9 collector.
            this is used by NetFlow9ProbeService to find collectors
    """
    _name = "NetFlow9Sink"
    _group = "Service Flags"

addservice(NetFlow9SinkService)

class ICMPProbeService(MonitoringService):
    _name = "ICMPProbe"
    _depends = ("Cron",)
    _configs = (
            'start_icmp_probe_lo.sh',
            'icmp_probe_lo.sh',
            'icmp_probe_lo.hosts',
            'icmp_probe_lo.hosts.verbose',
            'start_icmp_probe_if.sh',
            'icmp_probe_if.sh',
            'icmp_probe_if.hosts',
            'icmp_probe_if.hosts.verbose',
            )
    _dirs = ()
    _startup = (
            "rm -f /tmp/icmp_probe_lo.stop",
            "rm -f /tmp/icmp_probe_if.stop",
            "bash start_icmp_probe_lo.sh",
            "bash start_icmp_probe_if.sh",
            )
    _shutdown = ("> /tmp/icmp_probe_lo.stop", "> /tmp/icmp_probe_if.stop",)
    _validate = ()
    # TODO: wait for IGP to converge before starting to scan
    #_starttime = 300

    @classmethod
    def generateconfig(cls, node, filename, services):
        if filename == 'start_icmp_probe_lo.sh':
            return cls.generateStartLo(node)
        elif filename == 'icmp_probe_lo.sh':
            return cls.generateConfLo(node)
        elif filename == 'icmp_probe_lo.hosts':
            return cls.generateHostsLo(node)
        elif filename == 'icmp_probe_lo.hosts.verbose':
            return cls.generateHostsLo(node, True)
        elif filename == 'start_icmp_probe_if.sh':
            return cls.generateStartIf(node)
        elif filename == 'icmp_probe_if.sh':
            return cls.generateConfIf(node)
        elif filename == 'icmp_probe_if.hosts':
            return cls.generateHostsIf(node)
        elif filename == 'icmp_probe_if.hosts.verbose':
            return cls.generateHostsIf(node, True)

    @staticmethod
    def generateStartLo(node):
        confstr =  """\
#!/bin/bash

grep -v "icmp_probe_lo.sh" /etc/crontab && echo "*/5 * * * * root (cd $(pwd); bash $(pwd)/icmp_probe_lo.sh)" >> /etc/crontab

bash ./icmp_probe_lo.sh &
"""
        return confstr

    @staticmethod
    def generateConfLo(node):
        confstr =  """\
#!/bin/bash

set -e

# from: http://unix.stackexchange.com/a/19616
validIP4 ()
{
    result=1
    IFS='.' read na nb nc nd;
    for n in "$na" "$nb" "$nc" "$nd"; do
        [[ ${#n} -le 3 ]] && [[ "${n//[^0-9]/}" = "$n" ]] && [[ $n -lt 256 ]] || result=0 && break
    done
    echo "$result"
}

error=0
now=$(date +%Y%m%d-%H%M)
mkdir -p icmp_probe
out=icmp_probe/icmp_probe_lo.result.${now}

cmd4="nice -n19 ping -n -c1 -w3 "
cmd6="nice -n19 ping6 -n -c1 -w3 "

function abort {
  echo "error at host: $host" >> ${out}
  error=1
}

if [ \! -e /tmp/icmp_probe_lo.stop ]; then
    > ${out}

    for host in $(cat icmp_probe_lo.hosts); do
        isIPv4_res=$(echo $host | validIP4)

        if [ "$isIPv4_res" == "1" ]; then
            $cmd4 $host || $cmd4 $host || $cmd4 $host || abort
        else
            $cmd6 $host || $cmd6 $host || $cmd6 $host || abort
        fi
    done

    [ $error -eq 0 ] && echo "all ok" > ${out}
fi
"""
        return confstr

    @staticmethod
    def generateHostsLo(node, verbose=False):
        confstr_list =  []
        if not verbose:
            service_helpers.nodewalker(node, node, confstr_list,
                    ICMPProbeService.nodewalker_lo_callback)
        else:
            service_helpers.nodewalker(node, node, confstr_list,
                    ICMPProbeService.nodewalker_lo_verbose_callback)
        return ''.join(confstr_list)

    @staticmethod
    def nodewalker_lo_callback(startnode, currentnode):
        result = []
        if currentnode.enable_ipv6 and startnode.enable_ipv6:
            result.extend([str(currentnode.getLoopbackIPv6()), '\n'])
        if currentnode.enable_ipv4 and startnode.enable_ipv4:
            result.extend([str(currentnode.getLoopbackIPv4()), '\n'])
        return result

    @staticmethod
    def nodewalker_lo_verbose_callback(startnode, currentnode):
        result = []
        if currentnode.enable_ipv6 and startnode.enable_ipv6:
            result.extend([str(currentnode.getLoopbackIPv6()),
                    ' ', currentnode.name, '\n'])
        if currentnode.enable_ipv4 and startnode.enable_ipv4:
            result.extend([str(currentnode.getLoopbackIPv4()),
                    ' ', currentnode.name, '\n'])
        return result

    @staticmethod
    def generateStartIf(node):
        confstr =  """\
#!/bin/bash

grep -v "icmp_probe_if" /etc/crontab && echo "*/5 * * * * root (cd $(pwd); bash $(pwd)/icmp_probe_if.sh)" >> /etc/crontab

bash ./icmp_probe_if.sh &
"""
        return confstr

    @staticmethod
    def generateConfIf(node):
        confstr =  """\
#!/bin/bash

set -e

# from: http://unix.stackexchange.com/a/19616
validIP4 ()
{
    result=1
    IFS='.' read na nb nc nd;
    for n in "$na" "$nb" "$nc" "$nd"; do
        [[ ${#n} -le 3 ]] && [[ "${n//[^0-9]/}" = "$n" ]] && [[ $n -lt 256 ]] || result=0 && break
    done
    echo "$result"
}

error=0
now=$(date +%Y%m%d-%H%M)
mkdir -p icmp_probe
out=icmp_probe/icmp_probe_if.result.${now}

cmd4="nice -n19 ping -n -c1 -w3 "
cmd6="nice -n19 ping6 -n -c1 -w3 "

function abort {
  echo "error at host: $host" >> ${out}
  error=1
}

if [ \! -e /tmp/icmp_probe_if.stop ]; then
    > ${out}

    for host in $(cat icmp_probe_if.hosts); do
        isIPv4_res=$(echo $host | validIP4)

        if [ "$isIPv4_res" == "1" ]; then
            $cmd4 $host || $cmd4 $host || $cmd4 $host || abort
        else
            $cmd6 $host || $cmd6 $host || $cmd6 $host || abort
        fi
    done

    [ $error -eq 0 ] && echo "all ok" > ${out}
fi
"""
        return confstr

    @staticmethod
    def generateHostsIf(node, verbose=False):
        confstr_list =  []
        if not verbose:
            service_helpers.nodewalker(node, node, confstr_list,
                    ICMPProbeService.nodewalker_if_callback)
        else:
            service_helpers.nodewalker(node, node, confstr_list,
                    ICMPProbeService.nodewalker_if_verbose_callback)
        return ''.join(confstr_list)

    @staticmethod
    def nodewalker_if_callback(startnode, currentnode):
        result = []
        #if currentnode.enable_ipv6 and startnode.enable_ipv6:
        #    result.append(str(currentnode.getLoopbackIPv6()))
        if currentnode.enable_ipv4 and startnode.enable_ipv4:
            for intf in currentnode._netif.values():
                if hasattr(intf, 'control') and intf.control == True:
                    continue
                for addr in intf.addrlist:
                    if isIPv4Address(addr):
                        result.extend([addr.partition('/')[0], '\n'])
        if currentnode.enable_ipv6 and startnode.enable_ipv6:
            for intf in currentnode._netif.values():
                if hasattr(intf, 'control') and intf.control == True:
                    continue
                for addr in intf.addrlist:
                    if isIPv6Address(addr):
                        result.extend([addr.partition('/')[0], '\n'])
        return result

    @staticmethod
    def nodewalker_if_verbose_callback(startnode, currentnode):
        result = []
        #if currentnode.enable_ipv6 and startnode.enable_ipv6:
        #    result.append(str(currentnode.getLoopbackIPv6()))
        if currentnode.enable_ipv4 and startnode.enable_ipv4:
            for intf in currentnode._netif.values():
                for addr in intf.addrlist:
                    if isIPv4Address(addr):
                        result.extend([addr.partition('/')[0],
                        ' ', currentnode.name, '\n'])
        if currentnode.enable_ipv6 and startnode.enable_ipv6:
            for intf in currentnode._netif.values():
                for addr in intf.addrlist:
                    if isIPv6Address(addr):
                        result.extend([addr.partition('/')[0],
                        ' ', currentnode.name, '\n'])
        return result

addservice(ICMPProbeService)

class SNMPDService(MonitoringService):
    _name = "snmpd"
    _depends = ()
    _configs = ('/etc/snmp/snmpd.conf',)
    _dirs = (('/etc/snmp', 'union'), ('/run', 'bind'))
    _startup = ('/etc/init.d/snmpd start',)
    _shutdown = ('/etc/init.d/snmpd stop',)
    _validate = ()
    _starttime = 5

    @classmethod
    def generateconfig(cls, node, filename, services):
        if filename == '/etc/snmp/snmpd.conf':
            return cls.generateSnmpdConf(node)

    @staticmethod
    def generateSnmpdConf(node):
        config = []
        listenstatement = ''
        if node.enable_ipv4:
            listenstatement = 'agentAddress udp:161'
        elif node.enable_ipv6:
            listenstatement = 'agentAddress udp6:161'
        elif node.enable_ipv4 and node.enable_ipv6:
            listenstatement = 'agentAddress udp:161,udp6:161'

        config.append("""\
%s

rocommunity public  default

com2sec readonly default public
group MyROGroup v1 readonly
view all included .1 80
access MyROGroup "" any noauth exact all none none

master          agentx
agentXSocket    tcp:localhost:705

""" % (listenstatement))

        # interface/link bandwidth overrides
        override_base = 'override 1.3.6.1.2.1.2.2.1.5.'
        override_value_type = 'uinteger'
        overrides = []
        for localnetif in node._netif.values():
            bandwidth = localnetif.getparam('bw')
            if not bandwidth is None and bandwidth > 0:
                # get SNMP idx of this interface
                result, stdouterr = node.cmdresult(
                        ['/opt/BENOCS/bin/ifindex', str(localnetif.name)])

                if result != 0:
                    node.warn(('Could not determine SNMP interface number '
                            'for interface: %s - error: %s' % (
                            str(localnetif.name),
                            str(stdouterr))))
                    sflowd_argv.append((' -i %s' % str(localnetif.name)))
                else:
                    snmp_if_idx = stdouterr.decode().strip()

                    overrides.extend([override_base, snmp_if_idx, ' ',
                            override_value_type, ' ', str(bandwidth), '\n'])

        config.extend(overrides)

        return ''.join(config)

addservice(SNMPDService)

