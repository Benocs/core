# various CORE services that implement network and host monitoring
#
# Copyright (C) 2014 Robert Wuttke <robert@benocs.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


import os

from core.service import CoreService, addservice
from core.misc.ipaddr import IPv4Prefix, IPv6Prefix
from core.misc.utils import *
from core.constants import *

from core.services import utility

from core.services import service_helpers

class MonitoringService(utility.UtilService):
        ''' Parent class for monitoring services.
        '''
        _name = "MonitoringProcess"
        #_group = "Monitoring"
        _depends = ()
        _dirs = ()
        _configs = ()
        _startindex = 90
        _startup = ()
        _shutdown = ()

        @classmethod
        def generateconfig(cls,  node, filename, services):
                return ""

class NetFlow9ProbeService(MonitoringService):
    _name = "netflow9probe"
    _configs = ("startnetflow9probe.sh", "stopnetflow9probe.sh",
            "pmacctd_netflow9probe.conf")
    _dirs = ()
    _startup = ("sh startnetflow9probe.sh",)
    _shutdown = ("sh stopnetflow9probe.sh",)
    _validate = ()
    # TODO: wait for IGP to converge before starting monitoring (pmacctd will exit if no
    # route to collector is available)
    _starttime = 60

    @classmethod
    def generateconfig(cls, node, filename, services):
        ''' Use a startup script for launching sshd in order to wait for host
                key generation.
        '''

        if filename == "startnetflow9probe.sh":
            return cls.generateStartScript(cls._configs[2])
        elif filename == "stopnetflow9probe.sh":
            return cls.generateStopScript()
        elif filename == "pmacctd_netflow9probe.conf":
            return cls.generateConf(node)

    @staticmethod
    def generateStartScript(netflow9_cfgfile):
        return """\
#!/bin/sh
# auto-generated by pmacctd NetFlow9 service (monitoring.py)

pmacctd -f %s
""" % (netflow9_cfgfile)

    @staticmethod
    def generateStopScript():
        return """\
#!/bin/sh
# auto-generated by pmacctd NetFlow9 service (monitoring.py)

#kill $(cat /var/run/pmacctd_nf9.pid)
#kill -9 $(cat /var/run/pmacctd_nf9.pid)
killall pmacctd
"""

    @staticmethod
    def nodewalker_callback(startnode, currentnode):
        result = []
        # check if remote node is netflow9sink and for same AS
        if NetFlow9SinkService in currentnode.services and \
                startnode.netid == currentnode.netid:
            result = ['nfprobe_receiver: ',
                    list(currentnode._netif.values())[0].addrlist[0].partition('/')[0],
                    ':2055\n']
        return result

    """
    @staticmethod
    def nodewalker(startnode, currentnode, visited_list, receiver_list):

        print('current node: %s, netid: %s' % (str(currentnode.name),
                str(currentnode.netid)))
        visited_list.append(currentnode)

        # check if remote node is netflow9sink and for same AS
        if NetFlow9SinkService in currentnode.services and \
                startnode.netid == currentnode.netid:
            receiver_list.extend(['nfprobe_receiver: ',
                    list(currentnode._netif.values())[0].addrlist[0].partition('/')[0],
                    ':2055\n'])

        for localnetif in currentnode.netifs():
            for idx, net_netif in localnetif.net._netif.items():
                # skip our own interface
                if localnetif == net_netif.node:
                    continue

                if not net_netif.node in visited_list:
                    service_helpers.nodewalker(startnode, net_netif.node,
                            visited_list, receiver_list, nodewalker_callback)
    """

    @staticmethod
    def generateConf(node):
        confstr_list =  ["""\
! auto-generated by pmacctd NetFlow9 service (monitoring.py)

!pidfile: /var/run/pmacctd_nf9.pid

daemonize: true

"""]
        for intf in node.netifs():
            confstr_list.extend(['interface: ', intf.name, '\n'])

        confstr_list.append(
"""
!aggregate: src_host, dst_host, src_port, dst_port, proto, tos
plugins: nfprobe

""")

        # add any nfprobe9sink which is on our AS to the list of collectors
        service_helpers.nodewalker(node, node, [], confstr_list, NetFlow9ProbeService.nodewalker_callback)

        confstr_list.append(
"""
nfprobe_version: 9

nfprobe_timeouts: tcp=120:tcp.rst=4:tcp.fin=10:udp=10:icmp=10:general=120:expint=3:maxlife=3600
""")

        return ''.join(confstr_list)

addservice(NetFlow9ProbeService)


class NetFlow9SinkService(MonitoringService):
    """ dummy service marking nodes that implement a NetFlow9 collector.
            this is used by NetFlow9ProbeService to find collectors
    """
    _name = "netflow9sink"

addservice(NetFlow9SinkService)
